var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import * as React from 'react';
import { canUseDOM, Draggable } from '@progress/kendo-react-common';
import { closestTagName, getColumnIndex, getRowIndex } from './utils';
var hasRelativeStackingContext = function () {
    if (!canUseDOM || !document.body) {
        return false;
    }
    var top = 10;
    var parent = document.createElement('div');
    parent.style.transform = 'matrix(10, 0, 0, 10, 0, 0)';
    parent.innerHTML = "<div style=\"position: fixed; top: " + top + "px;\">child</div>";
    document.body.appendChild(parent);
    var isDifferent = parent.children[0].getBoundingClientRect().top !== top;
    document.body.removeChild(parent);
    return isDifferent;
};
var HAS_RELATIVE_STACKING_CONTEXT = hasRelativeStackingContext();
var relativeContextElement = function (element) {
    if (!element || !HAS_RELATIVE_STACKING_CONTEXT) {
        return null;
    }
    var node = element.parentElement;
    while (node) {
        if (window.getComputedStyle(node).transform !== 'none') {
            return node;
        }
        node = node.parentElement;
    }
};
var getOffset = function (offsetParent) {
    if (offsetParent && offsetParent.ownerDocument) {
        if (offsetParent !== offsetParent.ownerDocument.body) {
            var rect = offsetParent.getBoundingClientRect();
            return {
                left: rect.left - offsetParent.scrollLeft,
                top: rect.top - offsetParent.scrollTop
            };
        }
    }
    return { left: 0, top: 0 };
};
/** @hidden */
export var getSelectionOptions = function (selectable) {
    var enabled = selectable ?
        (typeof selectable.enabled === 'boolean' ? selectable.enabled : true) :
        false;
    var drag = selectable ? Boolean(selectable.drag) : false;
    var mode = selectable && selectable.mode ? selectable.mode : 'multiple';
    var cell = Boolean(selectable && selectable.cell);
    return { enabled: enabled, drag: drag, mode: mode, cell: cell };
};
/** @hidden */
export var GridSelection = function (props) {
    var onRelease = props.onRelease;
    var _a = getSelectionOptions(props.selectable), selectionEnabled = _a.enabled, selectionDrag = _a.drag, selectionMode = _a.mode, selectionCell = _a.cell;
    var draggableRef = React.useRef(null);
    var overlayElementRef = React.useRef(null);
    var dragStartRef = React.useRef({ clientX: 0, clientY: 0 });
    var _b = React.useState(null), overlaySettings = _b[0], setOverlaySettings = _b[1];
    var offsetParentRef = React.useRef();
    var isDraggedRef = React.useRef(false);
    var onPressHandler = React.useCallback(function (eventData) {
        var event = eventData.event;
        if (!draggableRef.current) {
            return;
        }
        offsetParentRef.current = relativeContextElement(draggableRef.current.element);
        dragStartRef.current = {
            clientY: event.clientY,
            clientX: event.clientX
        };
    }, []);
    var onDragHandler = React.useCallback(function (eventData) {
        var event = eventData.event;
        var _a = dragStartRef.current, clientX = _a.clientX, clientY = _a.clientY;
        if (!selectionDrag || selectionMode === 'single') {
            return;
        }
        if (Math.abs(clientY - event.clientY) > 5 || Math.abs(clientX - event.clientX) > 5) {
            isDraggedRef.current = true;
        }
        if (isDraggedRef.current) {
            var offset = getOffset(offsetParentRef.current);
            setOverlaySettings({
                top: Math.min(clientY, event.clientY) - offset.top,
                left: Math.min(clientX, event.clientX) - offset.left,
                width: Math.abs(event.clientX - clientX),
                height: Math.abs(event.clientY - clientY)
            });
        }
    }, [setOverlaySettings, selectionDrag, selectionMode]);
    var onReleaseHandler = React.useCallback(function (eventData) {
        var event = eventData.event;
        var _a = dragStartRef.current, clientX = _a.clientX, clientY = _a.clientY;
        if (!isDraggedRef.current) {
            var startElement = document.elementFromPoint(clientX, clientY);
            if (!startElement) {
                return;
            }
            var tdElement = closestTagName(startElement, 'TD');
            var trElement = closestTagName(startElement, 'TR');
            var colIndex = getColumnIndex(tdElement);
            var rowIndex = getRowIndex(trElement);
            if (tdElement && trElement && rowIndex !== undefined && colIndex !== undefined) {
                onRelease({
                    nativeEvent: event.originalEvent,
                    startRowIndex: rowIndex,
                    startColIndex: colIndex,
                    endRowIndex: rowIndex,
                    endColIndex: colIndex,
                    altKey: event.altKey,
                    shiftKey: event.shiftKey,
                    ctrlKey: event.ctrlKey,
                    metaKey: event.originalEvent.metaKey,
                    mode: selectionMode,
                    cell: selectionCell,
                    isDrag: false
                });
            }
        }
        else {
            var top_1 = Math.min(clientY, event.clientY);
            var left = Math.min(clientX, event.clientX);
            var bottom = Math.max(clientY, event.clientY);
            var right = Math.max(clientX, event.clientX);
            var overlayElement = overlayElementRef.current;
            if (!overlayElement) {
                return;
            }
            overlayElement.style.visibility = 'hidden';
            var startElement = document.elementFromPoint(left, top_1);
            var endElement = document.elementFromPoint(right, bottom);
            overlayElement.style.visibility = '';
            if (!startElement || !endElement) {
                return;
            }
            var startTdElement = closestTagName(startElement, 'TD');
            var startTrElement = closestTagName(startTdElement, 'TR');
            var endTdElement = closestTagName(endElement, 'TD');
            var endTrElement = closestTagName(endTdElement, 'TR');
            var startColIndex = getColumnIndex(startTdElement);
            var startRowIndex = getRowIndex(startTrElement);
            var endColIndex = getColumnIndex(endTdElement);
            var endRowIndex = getRowIndex(endTrElement);
            if (startColIndex !== undefined &&
                startRowIndex !== undefined &&
                endColIndex !== undefined &&
                endRowIndex !== undefined) {
                onRelease({
                    nativeEvent: event.originalEvent,
                    startRowIndex: startRowIndex,
                    startColIndex: startColIndex,
                    endRowIndex: endRowIndex,
                    endColIndex: endColIndex,
                    altKey: event.altKey,
                    shiftKey: event.shiftKey,
                    ctrlKey: event.ctrlKey,
                    metaKey: event.originalEvent.metaKey,
                    mode: selectionMode,
                    cell: selectionCell,
                    isDrag: true
                });
            }
        }
        setOverlaySettings(null);
        isDraggedRef.current = false;
        dragStartRef.current = { clientX: 0, clientY: 0 };
    }, [setOverlaySettings, selectionMode, selectionCell, onRelease]);
    if (!selectionEnabled) {
        return props.children;
    }
    return (React.createElement(React.Fragment, null,
        React.createElement(Draggable, { onPress: onPressHandler, onDrag: onDragHandler, onRelease: onReleaseHandler, ref: draggableRef }, props.children),
        overlaySettings && React.createElement("div", { ref: overlayElementRef, style: __assign({}, overlaySettings, { position: 'fixed' }), className: 'k-marquee-color' })));
};
//# sourceMappingURL=GridSelection.js.map